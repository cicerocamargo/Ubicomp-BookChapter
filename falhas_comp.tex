Confiabilidade e disponibilidade são características altamente desejadas em sistemas de computação, pois a humanidade depende cada vez mais de sistemas automatizados e informatizados para a realização de suas tarefas diárias. Dentre estes estão sistemas críticos, como um sistema que envolva transações financeiras ou software controlador de um avião, por exemplo, onde falhas podem causar prejuízo financeiro e/ou perda de vidas.

Os computadores (hardware + software) são, provavelmente, os sistemas mais complexos já inventados pelo homem. A complexidade das peças de hardware segue em constante crescimento, o que gera a possibilidade de inserção de defeitos em várias etapas do desenvolvimento, desde o nível elétrico até, por exemplo, algoritmos de predição implementados diretamente em hardware nos processadores. A área de software é ainda mais complexa e, por isso, ainda mais propensa a falhas. Até mesmo o ônibus espacial (\emph{Space Shuttle}) da NASA~\cite{BonacheaOnline}, desenvolvido com as mais cuidadosas tecnologias apresentou \emph{bugs} no código de seu sistema sistema, podendo resultar em uma catástrofe. Podemos extrapolar um pouco e afirmar que falhas são inevitáveis em computadores. Contudo, as consequências dessas falhas pode ser contornadas ou, ao menos minimizadas, se o design do software se prevenir das falhas que possam vir a ocorrer no sistema.

É notável o crescimento em confiabilidade na área de hardware~\cite{Weber} onde vimos uma grande cultura de tolerância a falhas se formar dos inseguros \emph{mainframes} a vávula, cujos proprietários sofriam, rotineiramente, com falhas de diversas origens, até os robustos \emph{laptops} (e \emph{smartphones}) que temos hoje para computação pessoal. Na área de software, por outro lado, os processos de desenvolvimento e os produtos estão cada vez mais complexos e apresentando cada vez mais \emph{bugs}. Uma vez que esses \emph{bugs} são quase inevitáveis, mecanismos de tolerância a falhas se tornam obrigatórios em sistemas onde a confiabilidade e disponibilidade é imprescindível.

\subsection{Falhas, erros e defeitos} % (fold)
\label{sub:falhas_erros_e_defeitos}

Com frequência usamos as palavras ``falha'', ``erro'' e ``defeito'' para designar problemas que fazem um módulo de software ou hardware funcionar de forma indevida. Contudo, na área de tolerância a falhas faz-se uma distinção destes três termos. Diversos autores da área possuem definições sutilmente diferentes para esses termos, e as definições que usaremos aqui são as mesmas econtradas em~\cite{koren2007fault}.

Uma \textbf{falha}, do inglês \emph{fault} (também traduzido como \textbf{falta}), ou \textbf{defeito} (\emph{failure}) pode ser algum problema diretamente no hardware ou algum \emph{bug} na programação do software. Já o \textbf{erro} é uma manifestação de uma falha.

Por exemplo, considere um circuito que faz a soma de dois números binários, porém com um dos bits de saída preso em $0$ (zero), independente da soma dos operandos. Este defeito ou falha no hardware só gerará um erro quando a soma dos operandos resultar em um valor em que aquele bit específico da saída não seria igual a zero. Outro exemplo, na área de software, é uma linha de código mal programada, a qual pode eventualmente acessar uma área de memória inválida. Esta falha de programação só irá gerar um erro quando, em tempo de execução, o programa acessar alguma área de memória inválida.

Falhas e erros podem, também, se propagar em um sistema. Por exemplo, o somador defeituoso pode passar um resultado errado para outros componentes que usarão sua saída, fazendo, atém mesmo com que erros sejam capturados em módulos não defeituosos. Programadores e projetistas devem prever \textbf{zonas de contenção} em seus sistemas para impedir que erros e defeitos se propaguem para outras partes do sistema. Por exemplo, um \emph{chip} queimado pode desligar outros componentes de hardware ligados a ele, a menos que a energia seja fornecida a cada componente de forma individual, ou haja um \emph{chip} ``estepe'' que é ativado em caso de falha do \emph{chip} ``titular''. Ainda, vários chips podem operar simultaneamente sobre o mesmo conjunto de dados, com suas saídas sendo passadas a um componente que faz uma votação sobre as respostas.

%Em~\ref{sub:redundancia} apresentaremos técnicas que lidam com diversos tipos de redundância.

% subsection falhas_erros_e_defeitos (end)

\subsection{Classificação de falhas de hardware} % (fold)
\label{sub:classificacao}

Falhas de hardware podem ser classificadas sob diversos aspectos. Em relação a seu tempo de duração, estas podem ser classificadas em falhas \emph{permanentes}, \emph{transientes}, ou \emph{intermitentes}. \emph{Falhas permanentes} são aquelas onde um componente falha e não volta a funcionar, como um LED que queima, por exemplo. \emph{Falhas transientes} são aquelas onde um certo componente apresenta funcionamento defeituoso e após algum tempo volta a funcionar correta e plenamente. Um exemplo pode ser uma célula de memória que tem seu valor alterado, porém sua funcionalidade segue intacta: uma reescrita na memória soluciona a falha ocorrida. \emph{Falhas intermitentes} são aquelas que não desaparecem por completo, onde um componente apresenta determinada falha com uma certa periodicidade. Uma falha intermitente apresenta períodos de quiescência, onde o componente funciona normalmente, e períodos de atividade, onde o componente falha. Um exemplo pode ser uma corrente de energia instável.

Falhas de hardware podem ser também classificadas em \emph{benignas} e \emph{maliciosas}. Uma falha \emph{benigna} é aquela que simplesmente faz o componente parar de funcionar, o que é relativamente fácil de tratar. No entanto, um componente poder seguir funcionando sem problemas aparentes, porém gerando resultados incorretos. Este tipo de falhas é mais difícil de identificar e pode gerar problemas delicados. Podemos pensar, por exemplo, em um avião cujo sensor de altitute mede um valor incorreto que é entregue no mostrador do piloto, o qual depende da corretude desta informação para guiar o avião. Este segundo tipo de falhas chamamos de \emph{maliciosa} (ou \emph{Bizantina}).
% subsection classificacao (end)

\subsection{Redundância} % (fold)
\label{sub:redundancia}

Praticamente todas as técnicas de tolerância a falhas envolvem algum tipo de redundância. Por redundância entende-se o fato de possuir mais de um componente (de software ou hardware) fornecendo a mesma funcionalidade. Em geral, as técnicas consistem em mecanismo de autogerenciamento dos componentes redundantes.

Existem basicamente quatro tipos de redundâncias: redundância de hardware, software, informação e tempo. %fix
Falhas de hardware geralmente são prevenidas com redundância de hardware, informação e tempo, enquanto falhas de software são prevenidas com redundância de software.

\emph{Redundância de hardware} em geral é obtida por peças de hardware extra que simplesmente detectam a falha de outro componente de hardware ou sobrescreve o efeito de sua falha. Esta redundância de hardware pode ser \emph{estática}, quando diversos componentes iguais, e.g. processadores, funcionam simultaneamente para realizar a mesma função, mascarando imediatamente uma falta, ou \emph{dinâmica}, quando um componente ``estepe'' é ativado quando outro falha, cada qual com seus prós e contras. Uma combinação destas duas técnicas é possível, resultando em uma \emph{Redundância híbrida de hardware}.
% subsection redundancia (end)

\subsection{Dependabilidade} % (fold)
\label{sub:dependabilidade}

Atributos 
Confiabilidade (reliability) 
capacidade de atender a especificação, dentro de condições definidas, 
durante certo período de funcionamento e condicionado a estar 
operacional no início do período 
Disponibilidade (availability) 
probabilidade do sistema estar operacional num instante de tempo 
determinado; alternância de períodos de funcionamento e reparo 
Segurança (safety) 
probabilidade do sistema ou estar operacional e executar sua função 
corretamente ou descontinuar suas funções de forma a não provocar 
dano a outros sistema ou pessoas que dele dependam 
Segurança (security) 
proteção contra falhas maliciosas, visando privacidade, autenticidade, 
integridade e irrepudiabilidade dos dados

% subsection dependabilidade (end)

